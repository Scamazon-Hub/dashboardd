<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSI Schaefer Report Parser</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- SheetJS -->
    <script lang="javascript" src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
</head>

<body class="bg-slate-50 text-slate-900 h-screen overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // --- COMPONENTS ---

        const FileUpload = ({ label, accept, onFileSelect, file }) => {
            return (
                <div class="flex flex-col gap-1">
                    <label class="text-xs font-semibold uppercase text-slate-500">{label}</label>
                    <div class="relative group">
                        <input
                            type="file"
                            accept={accept}
                            onChange={(e) => onFileSelect(e.target.files[0])}
                            class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
                        />
                        <div class={`border-2 border-dashed rounded px-3 py-2 text-sm flex items-center justify-between transition-colors ${file ? 'border-emerald-500 bg-emerald-50' : 'border-slate-300 hover:border-blue-400 bg-white'}`}>
                            <span class="truncate max-w-[200px]">{file ? file.name : "Select file..."}</span>
                            {file ? <i data-lucide="check-circle" class="w-4 h-4 text-emerald-500"></i> : <i data-lucide="upload" class="w-4 h-4 text-slate-400"></i>}
                        </div>
                    </div>
                </div>
            );
        };

        const DataTable = ({ title, columns, data }) => {
            if (!data || data.length === 0) return null;

            const copyToClipboard = () => {
                // Create a basic tab-separated string for pasting into Excel
                const headers = columns.map(c => c.header).join('\t');
                const rows = data.map(row => columns.map(c => {
                    const val = c.accessor(row);
                    return val === null || val === undefined ? '' : String(val).replace(/\t/g, ' ');
                }).join('\t')).join('\n');

                navigator.clipboard.writeText(headers + '\n' + rows).then(() => {
                    alert('Copied to clipboard!');
                });
            };

            return (
                <div class="bg-white border rounded-lg shadow-sm overflow-hidden flex flex-col max-h-[400px]">
                    <div class="px-4 py-3 border-b bg-slate-50 flex items-center justify-between">
                        <h3 class="font-bold text-slate-700">{title} <span class="text-slate-400 font-normal ml-2">({data.length} items)</span></h3>
                        <button onClick={copyToClipboard} class="text-xs bg-white border border-slate-300 hover:bg-slate-50 px-2 py-1 rounded flex items-center gap-1">
                            <i data-lucide="clipboard" class="w-3 h-3"></i> Copy Table
                        </button>
                    </div>
                    <div class="overflow-auto flex-1">
                        <table class="w-full text-sm text-left">
                            <thead class="text-xs text-slate-500 uppercase bg-slate-50 sticky top-0 border-b">
                                <tr>
                                    {columns.map((col, idx) => (
                                        <th key={idx} class="px-4 py-2 font-medium">{col.header}</th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-slate-100">
                                {data.map((row, rIdx) => (
                                    <tr key={rIdx} class="hover:bg-slate-50/50">
                                        {columns.map((col, cIdx) => (
                                            <td key={cIdx} class="px-4 py-2 truncate max-w-[250px]" title={col.accessor(row)}>
                                                {col.accessor(row)}
                                            </td>
                                        ))}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        // --- LOOKUP DATA (Hardcoded as fallback, potentially replaceable by CSV upload later) ---
        // Ideally this matches the "Data.csv" and "Assets.csv" user provided.
        // For this implementation, we will try to parse lookup files if provided, otherwise fail gracefully.

        const App = () => {
            const [files, setFiles] = useState({
                workOrder: null,
                parts: null,
                shiftReport: null // Optional: For dynamic lookups
            });
            const [processedData, setProcessedData] = useState({
                reactive: [],
                planned: [],
                spares: []
            });
            const [lookups, setLookups] = useState({
                engineers: {}, // "Full Name" -> "Initials"
                assets: {},    // "ArticleNo" -> { location: "...", decision: "..." }
                reasonCodes: {} // "ID" -> "Reason"
            });

            useEffect(() => {
                lucide.createIcons();
            }, [files, processedData]);

            const handleFile = (key, file) => {
                setFiles(prev => ({ ...prev, [key]: file }));
            };

            const readExcel = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        resolve(workbook);
                    };
                    reader.readAsArrayBuffer(file);
                });
            };

            const parseWorkBookToJson = (workbook, sheetName = null) => {
                const name = sheetName || workbook.SheetNames[0];
                const worksheet = workbook.Sheets[name];
                return XLSX.utils.sheet_to_json(worksheet, { defval: "" });
            };

            const processFiles = async () => {
                if (!files.workOrder) {
                    alert("Please upload the Work Order export at minimum.");
                    return;
                }

                try {
                    // 1. Parse Work Orders
                    const wbWorkOrders = await readExcel(files.workOrder);
                    // Work order export usually has one sheet, typically "Data" or just the first one
                    const woData = parseWorkBookToJson(wbWorkOrders);

                    // 2. Parse Parts (if available)
                    let partsData = [];
                    if (files.parts) {
                        const wbParts = await readExcel(files.parts);
                        partsData = parseWorkBookToJson(wbParts);
                    }

                    // 3. Parse Shift Report Lookups (if available)
                    const tempLookups = {
                        engineers: {
                            "Chris McGhee": "CM",
                            "Christopher McGhee": "CM",
                            "Alf Fidoe": "AF",
                            "Chris Dare": "CD",
                            "Nick Barton": "NB",
                            "Harry Shepherd": "HS",
                            "Will Stovin": "WS",
                            "Christopher Dare": "CD",
                            "Nicholas Barton": "NB",
                            "Harrison Shepherd": "HS",
                            "William Stovin": "WS"
                        },
                        assets: {},
                        reasonCodes: {}
                    };

                    if (files.shiftReport) {
                        const wbShift = await readExcel(files.shiftReport);

                        // Try to find "Data" sheet for Engineers (override/add to defaults)
                        if (wbShift.SheetNames.includes("Data")) {
                            const dataRows = XLSX.utils.sheet_to_json(wbShift.Sheets["Data"], { header: 1 });
                            dataRows.forEach(row => {
                                if (row[1] && row[2] && typeof row[1] === 'string' && row[1].length > 3) {
                                    tempLookups.engineers[row[1].trim()] = row[2].trim();
                                }
                            });
                        }

                        if (wbShift.SheetNames.includes("Assets")) {
                            const assetRows = XLSX.utils.sheet_to_json(wbShift.Sheets["Assets"]);
                            assetRows.forEach(row => {
                                const partNo = row["PART NUMBER"];
                                if (partNo) {
                                    tempLookups.assets[partNo] = {
                                        location: row["Storage Location"] || "",
                                        status: row["Status"] || ""
                                    };
                                }
                            });
                        }
                    }

                    // --- PROCESSING LOGIC ---

                    // Helpers
                    const getTime = (val) => {
                        if (val === null || val === undefined || val === '') return '';

                        // Handle Excel Serial Date (Number) e.g. 46003.778
                        if (typeof val === 'number') {
                            // Extract fractional day part for time
                            const fractionalDay = val % 1;
                            // Round to nearest second to avoid precision issues
                            const totalSeconds = Math.round(fractionalDay * 86400);
                            const h = Math.floor(totalSeconds / 3600);
                            const m = Math.floor((totalSeconds % 3600) / 60);
                            return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                        }

                        // Handle Date objects if parsing produces them
                        if (val instanceof Date) {
                            return val.toTimeString().split(' ')[0].substring(0, 5);
                        }

                        const str = String(val);
                        // If it's a date string "YYYY-MM-DD HH:MM:SS" take time part
                        if (str.includes('T')) return str.split('T')[1].substring(0, 5);
                        return str.includes(' ') ? str.split(' ')[1].substring(0, 5) : str;
                        return str.includes(' ') ? str.split(' ')[1].substring(0, 5) : str;
                    };

                    const getInitials = (fullName) => tempLookups.engineers[fullName] || fullName?.split(' ').map(n => n[0]).join('') || "UNK";

                    // Helper: Get numeric minutes from HH:MM string for sorting
                    const getMinutes = (timeStr) => {
                        if (!timeStr || !timeStr.includes(':')) return 9999;
                        const [h, m] = timeStr.split(':').map(Number);
                        return (h * 60) + m;
                    };

                    // Helper: Determine Shift (AM = 06:00 - 14:30)
                    const getShift = (timeStr) => {
                        const mins = getMinutes(timeStr);
                        // AM: 06:00 (360) to 14:30 (870)
                        if (mins >= 360 && mins < 870) return "AM";
                        // PM: 14:00 onwards (overlap handled by logic preference, assuming rest is PM)
                        if (mins >= 840) return "PM";
                        return "AM"; // Default or Early Morning to AM? Or "Other"
                    };

                    const newReactive = [];
                    const newPlanned = [];

                    woData.forEach(row => {
                        const isUnplanned = String(row.IsUnplanned).toLowerCase() === 'true';
                        const type = String(row.Type || "");

                        // Reactive Logic
                        if (isUnplanned || type.includes("Corrective")) {
                            let manHours = "00:00";
                            const minutes = parseFloat(row["Working Time Total Min"] || 0);
                            if (!isNaN(minutes)) {
                                const h = Math.floor(minutes / 60);
                                const m = Math.floor(minutes % 60);
                                manHours = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                            }

                            newReactive.push({
                                timeCalled: getTime(row.StartedAt),
                                timeBack: getTime(row.ClosedAt),
                                equipment: row.Asset,
                                initial: getInitials(row.Technicians || row.Technician),
                                fault: row.Comment || row["Cause Text"],
                                hours: manHours,
                            });
                        } else {
                            // Planned Logic
                            // Filter: IsUnplanned = False
                            const startTime = getTime(row.StartedAt);
                            newPlanned.push({
                                shift: getShift(startTime),
                                time: startTime,
                                asset: row.Asset,
                                status: row.Status === "Closed" ? "Complete" : row.Status,
                                comment: row.Comment
                            });
                        }
                    });

                    // Sort Reactive: Early first (Ascending Time)
                    newReactive.sort((a, b) => getMinutes(a.timeCalled) - getMinutes(b.timeCalled));

                    // Sort Planned: AM first, then by Time
                    newPlanned.sort((a, b) => {
                        if (a.shift !== b.shift) {
                            return a.shift === "AM" ? -1 : 1; // AM before PM
                        }
                        return getMinutes(a.time) - getMinutes(b.time);
                    });

                    // Spares Logic
                    /*
                    Mapping:
                    ART # -> ArticleNo (Parts)
                    LOCATION -> Lookup in Assets using ArticleNo
                    DESC -> Article Alias (Parts)
                    CATEGORY -> 3 (Wear Part) default?
                    REASON -> "Wear Part"
                    QTY -> Amount (Parts)
                    NAME -> Lookup Technicians from WorkOrders (Parts.WorkorderId -> WorkOrders.Id)
                    DATE -> Date (Parts)
                    DECISION -> Lookup Status in Assets (e.g. Quarantined)
                    */

                    // Index Work Ordes by Id for fast lookup
                    const woMap = {};
                    woData.forEach(r => woMap[r.Id] = r);

                    const newSpares = partsData.map(part => {
                        const wo = woMap[part["Workorder Id"]];
                        const assetInfo = tempLookups.assets[part.ArticleNo] || {};

                        return {
                            artNo: part.ArticleNo,
                            location: assetInfo.location || "Unknown",
                            desc: part["Article Alias"] || part.Product,
                            category: "3", // Default from example
                            reason: "Wear Part", // Default from example
                            qty: part.Amount,
                            name: wo ? getInitials(wo.Technicians || wo.Technician) : "UNK",
                            date: String(part.Date).split(' ')[0], // just date part
                            decision: assetInfo.status || ""
                        };
                    });

                    setProcessedData({
                        reactive: newReactive,
                        planned: newPlanned,
                        spares: newSpares
                    });

                } catch (error) {
                    console.error(error);
                    alert("Error processing files: " + error.message);
                }
            };

            return (
                <div class="flex h-screen w-full">
                    {/* Sidebar / Controls */}
                    <div class="w-80 bg-white border-r p-6 flex flex-col gap-6 shrink-0 overflow-y-auto">
                        <div>
                            <h1 class="text-xl font-bold text-slate-800 tracking-tight">SSI Parser</h1>
                            <p class="text-xs text-slate-500 mt-1">Upload export files to generate reports.</p>
                        </div>

                        <div class="space-y-4">
                            <FileUpload
                                label="Work Orders Export (.xlsx)"
                                accept=".xlsx,.csv"
                                file={files.workOrder}
                                onFileSelect={f => handleFile('workOrder', f)}
                            />
                            <FileUpload
                                label="Parts Export (.xlsx)"
                                accept=".xlsx,.csv"
                                file={files.parts}
                                onFileSelect={f => handleFile('parts', f)}
                            />
                            <div class="border-t pt-4">
                                <FileUpload
                                    label="Shift Report / Lookups (.xlsx)"
                                    accept=".xlsx"
                                    file={files.shiftReport}
                                    onFileSelect={f => handleFile('shiftReport', f)}
                                />
                                <p class="text-[10px] text-slate-400 mt-1 leading-tight">
                                    Optional: Upload master Shift Report for Asset Locations. Engineer initials are pre-loaded.
                                </p>
                            </div>
                        </div>

                        <button
                            onClick={processFiles}
                            class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded shadow-sm transition-all active:scale-95"
                        >
                            Generate Report
                        </button>
                    </div>

                    {/* Main Content / Tables */}
                    <div class="flex-1 bg-slate-50 p-8 overflow-y-auto space-y-8">
                        {/* 1. Reactive Tasks */}
                        <DataTable
                            title="Reactive Tasks"
                            data={processedData.reactive}
                            columns={[
                                { header: 'Time Called', accessor: d => d.timeCalled },
                                { header: 'Time Back', accessor: d => d.timeBack },
                                { header: 'Equipment', accessor: d => d.equipment },
                                { header: 'Initials', accessor: d => d.initial },
                                { header: 'Fault', accessor: d => d.fault },
                                { header: 'Hours', accessor: d => d.hours },
                            ]}
                        />

                        {/* 2. Planned Maintenance */}
                        <DataTable
                            title="Planned Maintenance"
                            data={processedData.planned}
                            columns={[
                                { header: 'Shift', accessor: d => d.shift },
                                { header: 'Time', accessor: d => d.time },
                                { header: 'Asset / Task', accessor: d => d.asset },
                                { header: 'Status', accessor: d => d.status },
                                { header: 'Comment', accessor: d => d.comment },
                            ]}
                        />

                        {/* 3. Spares Used */}
                        <DataTable
                            title="Spares Used"
                            data={processedData.spares}
                            columns={[
                                { header: 'ART #', accessor: d => d.artNo },
                                { header: 'LOCATION', accessor: d => d.location },
                                { header: 'DESC', accessor: d => d.desc },
                                { header: 'CAT', accessor: d => d.category },
                                { header: 'REASON', accessor: d => d.reason },
                                { header: 'QTY', accessor: d => d.qty },
                                { header: 'NAME', accessor: d => d.name },
                                { header: 'DATE', accessor: d => d.date },
                                { header: 'DECISION', accessor: d => d.decision },
                            ]}
                        />
                    </div>
                </div >
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>